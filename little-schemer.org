#+title: "The Little Schemer" exercises and solutions
#+author: aabm
#+startup: overview

* Toys

** Law of Car

The primitive =car= is defined only for non-empty lists.

** Law of Cdr

The primitive =cdr= is defined only for non-empty lists. The =cdr= of any non-empty list is always another list.

** Law of Cons

The primitive =cons= takes two arguments. The second argument to =cons= must be a list. The result is a list.

** Law of Null?

The primitive =null?= is defined only for lists.

** Law of Eq?

The primitive =eq?= takes two arguments. Each must be a non-numeric atom.

** atom?

An elementary function defined early. Notice how, in Scheme, functions
are simply variables that contain lambdas.

This function checks whether an argument =x= is an atom.

#+begin_src scheme :tangle src/1.scm
  (define atom?
    (lambda (x)
      (and (not (pair? x)) (not (null? x)))))
#+end_src

* Do it, Do it Again, and Again, and Again...

** lat?

This function checks whether =l= is a list of atoms. It does this by
going over each S-expression it contains and checking them
individually.

#+begin_src scheme :tangle src/2.scm
  (define lat?
    (lambda (l)
      (cond
       ((null? l) #t)
       ((atom? (car l)) (lat? (cdr l)))
       (else #f))))
#+end_src

*** Breaking it down

This section checks whether =l= is the null list. If not, the function
continues. If true, the function returns #t.

#+begin_src scheme
  ((null? l) #t)
#+end_src

This is probably the more interesting section of the function. It
checks whether the =car= of =l= is an atom, and if so, call the
function again on the =cdr= of =l=, recursively.

#+begin_src scheme
((atom? (car l)) (lat? (cdr l)))
#+end_src

Finally, if all else fails, then the function returns #f.

** member?

This function checks whether atom =a= is a member of list =lat=. It
does this by going over each S-expression in =lat=, comparing them to
=a=.

#+begin_src scheme :tangle src/2.scm
  (define member?
    (lambda (a lat)
      (cond
       ((null? lat) #f)
       (else (or (eq? (car lat) a)
                 (member? a (cdr lat)))))))
#+end_src

*** Breaking it down

This first section checks whether the list =lat= is null. If so, then
the function returns #f. If not, then the function continues.

#+begin_src scheme
((null? lat) #f)
#+end_src

The function already moves on to the alternative, no consequence
here. The alternative routine is to check whether either a) the =car=
of =lat= is equal to =a=, or b) run the function again on the =cdr= of
=lat=, recursively.

** The First Commandment

Always ask =null?= as the first question in expressing any function.

* Cons the Magnificent

** rember

This function recurs over a list of atoms =lat= and returns =lat= with the first occurrence of atom =a= removed.

#+begin_src scheme :tangle src/3.scm
  (define rember
    (lambda (a lat)
      (cond
       ((null? lat) (quote ()))
       ((eq? (car lat) a) (cdr lat))
       (else (cons (car lat)
                   (rember a (cdr lat)))))))
#+end_src


*** Breaking it down

This first bit checks if the list =lat= is null. If so, it returns the null list. If not, the function continues.

#+begin_src scheme
((null? lat) (quote ()))
#+end_src

This section checks whether the =car= of =lat= is equal to =a=. If so, then the function returns the =cdr= of =lat=, which is equivalent to =lat= minus the first ocurrence of =a=. If not, then the function continues.

#+begin_src scheme
((eq? (car lat) a) (cdr lat))
#+end_src

If the above conditions and consequences fail, then the function moves on to =else=. This section recurs over =lat=, checking each individual atom, while also storing the atoms it has recurred over, which will be consed onto the final list.

#+begin_src scheme
(else (cons (car lat) (rember a (cdr lat))))
#+end_src
** The Second Commandment

Use =cons= to build lists.

** firsts

This function takes a list of lists =l= and returns the list of the first S-expressions in each sublist contained in =l=.

#+begin_src scheme :tangle src/3.scm
  (define firsts
    (lambda (l)
      (cond
       ((null? l) (quote ()))
       (else (cons (car (car l))
                   (firsts (cdr l)))))))
#+end_src

*** Breaking it down

The first section, as per the First Commandment, checks if the list =l= is null. If so, the function simply returns =l=. If not, then it continues.

#+begin_src scheme
((null? l) (quote ()))
#+end_src

The next section is the =else= section. It recurs over =l=, using =car= to go over each list, taking each sublists own =car=. Meanwhile, it stores each =car= to be consed to the final list afterwards.

#+begin_src scheme
(else (cons (car (car l)) (firsts (cdr l))))
#+end_src

** The Third Commandment

When building a list, describe the first typical element, and then
=cons= it onto the natural recursion.

** insertR


This function takes three arguments, atoms =new= and =old= and a list
of atoms =lat=. It recurs over =lat=, looking for atom =old=, and adds
atom =new= to the right of =old=.

#+begin_src scheme :tangle src/3.scm
  (define insertR
    (lambda (new old lat)
      (cond
       ((null? lat) (quote ()))
       ((eq? (car lat) old)
        (cons old (cons new (cdr lat))))
       (else
        (cons (car lat) (insertR new old (cdr lat)))))))
#+end_src

*** Breaking it down

We start with the First Commandment. I'll skip explaining that one
from now on since it seems obvious.

The next part checks whether the =car= of =lat= is equal to =old=. If
so, it adds =new= to the =cdr= of =lat=, to which =old= is then
consed.

#+begin_src scheme
  ((eq? (car lat) old)
   (cons old (cons new (cdr lat))))
#+end_src

The next section is the =else= block. It recurs =insertR= over ~(cdr
lat)~, while consing the =car= of =lat= to the result to ensure the
list is correct.

#+begin_src scheme
  (else
   (cons (car lat) (insertR new old (cdr lat))))
#+end_src

** insertL

This one functions similarly to the one above, except instead of
adding atom =new= to the right of atom =old=, it adds it to the left.

#+begin_src scheme :tangle src/3.scm
  (define insertL
    (lambda (new old lat)
      (cond
       ((null? lat) (quote ()))
       ((eq? (car lat) old)
        (cons new lat))
       (else
        (cons (car lat) (insertL new old (cdr lat)))))))
#+end_src

*** Breaking it down

This section checks whether =old= is the same as the =car= of
=lat=. If so, it conses =new= onto =lat= and finishes. If not, the
function continues.

#+begin_src scheme
  ((eq? (car lat) old)
   (cons new lat))
#+end_src

This part recurses over the =cdr= of =lat=, and conses the =car= of
=lat= on top of the final list.

#+begin_src scheme
  (else
   (cons (car lat) (insertL new old (cdr lat))))
#+end_src

** subst

I'm not even going to bother explaining this function in depth. It is
very similar in functioning to =insertR= and =insertL=, except instead
of adding an atom to a certain position, it replaces =old= with =new=.

#+begin_src scheme :tangle src/3.scm
  (define subst
    (lambda (new old lat)
      (cond
       ((null? lat) (quote ()))
       ((eq? (car lat) old)
        (cons new (cdr lat)))
       (else
        (cons (car lat)
              (subst new old (cdr lat)))))))
#+end_src

** subst2

This one works similarly to the above =subst=, except instead of
replacing only one atom, it replaces the first occurrence of either
one of two atoms, =o1= or =o2=, with =new=.

#+begin_src scheme :tangle src/3.scm
  (define subst2
    (lambda (new o1 o2 lat)
      (cond
       ((null? lat) (quote ()))
       ((or (eq? (car lat) o1)
            (eq? (car lat) o2))
        (cons new (cdr lat)))
       (else
        (cons (car lat)
              (subst2 new o1 o2
                      (cdr lat)))))))
#+end_src

** multirember

This is the =rember= function from above but with an extra level of
recursion. This makes it able to replace all occurrences of atom =a=
within =lat=.

#+begin_src scheme :tangle src/3.scm
  (define multirember
    (lambda (a lat)
      (cond
       ((null? lat) (quote ()))
       ((eq? (car lat) a)
        (multirember a (cdr lat)))
       (else
        (cons (car lat)
              (multirember a (cdr lat)))))))
#+end_src

** multiinsertR

#+begin_src scheme :tangle src/3.scm
  (define multiinsertR
    (lambda (new old lat)
      (cond
       ((null? lat) (quote ()))
       ((eq? (car lat) old)
        (cons old (cons new (multiinsertR new old (cdr lat)))))
       (else (cons (car lat)
                   (multiinsertR new old (cdr lat)))))))
#+end_src

** multiinsertL

#+begin_src scheme :tangle src/3.scm
  (define multiinsertL
    (lambda (new old lat)
      (cond
       ((null? lat) (quote ()))
       ((eq? (car lat) old)
        (cons new (cons old (multiinsertL new old (cdr lat)))))
       (else
        (cons (car lat)
              (multiinsertL new old (cdr lat)))))))
#+end_src

** The Fourth Commandment

Always change at least one argument while recurring. It must be
changed to be closer to termination. The changing argument must be
tested in the termination condition: when using =cdr=, test termination
with =null?=.

** multisubst

#+begin_src scheme :tangle src/3.scm
  (define multisubst
    (lambda (new old lat)
      (cond
       ((null? lat) (quote ()))
       ((eq? (car lat) old)
        (cons new
              (multisubst new old (cdr lat))))
       (else
        (cons (car lat)
              (multisubst new old (cdr lat)))))))
#+end_src

* Numbers Games

** add1 and sub1

#+begin_src scheme :tangle src/4.scm
  (define add1
    (lambda (n)
      (+ n 1)))

  (define sub1
    (lambda (n)
      (- n 1)))
#+end_src

** plus and minus

Reimplementing the basic mathematical operations of addition and
subtraction using recursion.

#+begin_src scheme :tangle src/4.scm
  (define plus
    (lambda (n m)
      (cond
       ((zero? m) n)
       (else
        (add1 (plus n (sub1 m)))))))

  (define minus
    (lambda (n m)
      (cond
       ((zero? m) n)
       (else
        (sub1 (minus n (sub1 m)))))))
#+end_src

** tup?

A custom function I made as the concept of a =tup= was introduced. It
checks whether a list is a list of numbers. Then I realized this is
just a reimplementation of =lat?=, but for tups.

#+begin_src scheme :tangle src/4.scm
  (define tup?
    (lambda (tup)
      (cond
       ((null? tup) #t)
       ((number? (car tup)) (tup? (cdr tup)))
       (else #f))))
#+end_src

** addtup

This function takes a tup =tup= and adds all the numbers in it, using
recursion and the above defined =plus= function.

#+begin_src scheme :tangle src/4.scm
  (define addtup
    (lambda (tup)
      (cond
       ((null? tup) 0)
       (else
        (plus (car tup)
              (addtup (cdr tup)))))))
#+end_src

** The First Commandment (revised)

When recurring on a list of atoms, =lat=, ask two questions about it:
~(null? tat)~ and else.  When recurring on a number, =n=, ask two
questions about it: ~(zero? n)~ and =else=.

** mult (x)

#+begin_src scheme :tangle src/4.scm
  (define x
    (lambda (n m)
      (cond
       ((zero? m) 0)
       (else
        (plus n (x n (sub1 m)))))))
#+end_src

** The Fourth Commandment (revised)

Always change at least one argument while recurring. It must be
changed to be closer to termination. The changing argument must be
tested in the termination condition:

- when using =cdr=, test termination with =null?=.
- when using =sub1=, test termination with =zero?=.

** The Fifth Commandment

When building a value with =plus=, always use 0 for the value of the
terminating line, for adding 0 does not change the value of an
addition.

When building a value with =x=, always use 1 for the value of the
terminating line, for multiplying by 1 does not change the value of a
multiplication.

When building a value with =cons=, always consider of the terminating
line.

** tup+

This function takes two arguments: =tup1= and =tup2=, both being of
the same length. It adds together the individual elements of each tup
and returns a tup.

This function works by doing something a bit special: it recurs over two
separate tups, instead of just one.

#+begin_src scheme :tangle src/4.scm
  (define tup+
    (lambda (tup1 tup2)
      (cond
       ((null? tup1) tup2)
       ((null? tup2) tup1)
       (else
        (cons (+ (car tup1) (car tup2))
              (tup+ (cdr tup1) (cdr tup2)))))))
#+end_src

** > and <

#+begin_src scheme :tangle src/4.scm
  (define >
    (lambda (n m)
      (cond
       ((zero? n) #f)
       ((zero? m) #t)
       (else
        (> (sub1 n) (sub1 m))))))

  (define <
    (lambda (n m)
      (cond
       ((zero? m) #f)
       ((zero? n) #t)
       (else
        (< (sub1 n) (sub1 m))))))

  (define =
    (lambda (n m)
      (cond
       ((< n m) #f)
       ((> n m) #f)
       (else #t))))

#+end_src
