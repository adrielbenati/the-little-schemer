#+title: "The Little Schemer" exercises and solutions
#+author: aabm
#+startup: overview

* Toys

** Law of Car

The primitive =car= is defined only for non-empty lists.

** Law of Cdr

The primitive =cdr= is defined only for non-empty lists. The =cdr= of any non-empty list is always another list.

** Law of Cons

The primitive =cons= takes two arguments. The second argument to =cons= must be a list. The result is a list.

** Law of Null?

The primitive =null?= is defined only for lists.

** Law of Eq?

The primitive =eq?= takes two arguments. Each must be a non-numeric atom.

** atom?

An elementary function defined early. Notice how, in Scheme, functions
are simply variables that contain lambdas.

This function checks whether an argument =x= is an atom.

#+begin_src scheme :tangle src/1.scm
  (define atom?
    (lambda (x)
      (and (not (pair? x)) (not (null? x)))))
#+end_src

* Do it, Do it Again, and Again, and Again...

** lat?

This function checks whether =l= is a list of atoms. It does this by
going over each S-expression it contains and checking them
individually.

#+begin_src scheme :tangle src/2.scm
  (define lat?
    (lambda (l)
      (cond
       ((null? l) #t)
       ((atom? (car l)) (lat? (cdr l)))
       (else #f))))
#+end_src

*** Breaking it down

This section checks whether =l= is the null list. If not, the function
continues. If true, the function returns #t.

#+begin_src scheme
  ((null? l) #t)
#+end_src

This is probably the more interesting section of the function. It
checks whether the =car= of =l= is an atom, and if so, call the
function again on the =cdr= of =l=, recursively.

#+begin_src scheme
((atom? (car l)) (lat? (cdr l)))
#+end_src

Finally, if all else fails, then the function returns #f.

** member?

This function checks whether atom =a= is a member of list =lat=. It
does this by going over each S-expression in =lat=, comparing them to
=a=.

#+begin_src scheme :tangle src/2.scm
  (define member?
    (lambda (a lat)
      (cond
       ((null? lat) #f)
       (else (or (eq? (car lat) a)
                 (member? a (cdr lat)))))))
#+end_src

*** Breaking it down

This first section checks whether the list =lat= is null. If so, then
the function returns #f. If not, then the function continues.

#+begin_src scheme
((null? lat) #f)
#+end_src

The function already moves on to the alternative, no consequence
here. The alternative routine is to check whether either a) the =car=
of =lat= is equal to =a=, or b) run the function again on the =cdr= of
=lat=, recursively.

** The First Commandment

Always ask =null?= as the first question in expressing any function.

* Cons the Magnificent

** rember

This function recurs over a list of atoms =lat= and returns =lat= with the first occurrence of atom =a= removed.

#+begin_src scheme :tangle src/3.scm
  (define rember
    (lambda (a lat)
      (cond
       ((null? lat) (quote ()))
       ((eq? (car lat) a) (cdr lat))
       (else (cons (car lat)
                   (rember a (cdr lat)))))))
#+end_src


*** Breaking it down

This first bit checks if the list =lat= is null. If so, it returns the null list. If not, the function continues.

#+begin_src scheme
((null? lat) (quote ()))
#+end_src

This section checks whether the =car= of =lat= is equal to =a=. If so, then the function returns the =cdr= of =lat=, which is equivalent to =lat= minus the first ocurrence of =a=. If not, then the function continues.

#+begin_src scheme
((eq? (car lat) a) (cdr lat))
#+end_src

If the above conditions and consequences fail, then the function moves on to =else=. This section recurs over =lat=, checking each individual atom, while also storing the atoms it has recurred over, which will be consed onto the final list.

#+begin_src scheme
(else (cons (car lat) (rember a (cdr lat))))
#+end_src
** The Second Commandment

Use =cons= to build lists.

** firsts

This function takes a list of lists =l= and returns the list of the first S-expressions in each sublist contained in =l=.

#+begin_src scheme :tangle src/3.scm
  (define firsts
    (lambda (l)
      (cond
       ((null? l) (quote ()))
       (else (cons (car (car l))
                   (firsts (cdr l)))))))
#+end_src

*** Breaking it down

The first section, as per the First Commandment, checks if the list =l= is null. If so, the function simply returns =l=. If not, then it continues.

#+begin_src scheme
((null? l) (quote ()))
#+end_src

The next section is the =else= section. It recurs over =l=, using =car= to go over each list, taking each sublists own =car=. Meanwhile, it stores each =car= to be consed to the final list afterwards.

#+begin_src scheme
(else (cons (car (car l)) (firsts (cdr l))))
#+end_src

** The Third Commandment

When building a list, describe the first typical element, and then
=cons= it onto the natural recursion.

** insertR


This function takes three arguments, atoms =new= and =old= and a list
of atoms =lat=. It recurs over =lat=, looking for atom =old=, and adds
atom =new= to the right of =old=.

#+begin_src scheme :tangle src/3.scm
  (define insertR
    (lambda (new old lat)
      (cond
       ((null? lat) (quote ()))
       ((eq? (car lat) old)
        (cons old (cons new (cdr lat))))
       (else
        (cons (car lat) (insertR new old (cdr lat)))))))
#+end_src

*** Breaking it down

We start with the First Commandment. I'll skip explaining that one
from now on since it seems obvious.

The next part checks whether the =car= of =lat= is equal to =old=. If
so, it adds =new= to the =cdr= of =lat=, to which =old= is then
consed.

#+begin_src scheme
  ((eq? (car lat) old)
   (cons old (cons new (cdr lat))))
#+end_src

The next section is the =else= block. It recurs =insertR= over ~(cdr
lat)~, while consing the =car= of =lat= to the result to ensure the
list is correct.

#+begin_src scheme
  (else
   (cons (car lat) (insertR new old (cdr lat))))
#+end_src

** insertL

This one functions similarly to the one above, except instead of
adding atom =new= to the right of atom =old=, it adds it to the left.

#+begin_src scheme :tangle src/3.scm
  (define insertL
    (lambda (new old lat)
      (cond
       ((null? lat) (quote ()))
       ((eq? (car lat) old)
        (cons new lat))
       (else
        (cons (car lat) (insertL new old (cdr lat)))))))
#+end_src

*** Breaking it down

This section checks whether =old= is the same as the =car= of
=lat=. If so, it conses =new= onto =lat= and finishes. If not, the
function continues.

#+begin_src scheme
  ((eq? (car lat) old)
   (cons new lat))
#+end_src

This part recurses over the =cdr= of =lat=, and conses the =car= of
=lat= on top of the final list.

#+begin_src scheme
  (else
   (cons (car lat) (insertL new old (cdr lat))))
#+end_src

** subst

I'm not even going to bother explaining this function in depth. It is very similar in functioning to =insertR= and =insertL=, except instead of adding an atom to a certain position, it replaces =old= with =new=.

#+begin_src scheme :tangle src/3.scm
  (define subst
    (lambda (new old lat)
      (cond
       ((null? lat) (quote ()))
       ((eq? (car lat) old)
        (cons new (cdr lat)))
       (else
        (cons (car lat)
              (subst new old (cdr lat)))))))
#+end_src

** subst2

This one works similarly to the above =subst=, except instead of replacing only one atom, it replaces the first occurrence of either one of two atoms, =o1= or =o2=, with =new=.

#+begin_src scheme :tangle src/3.scm
  (define subst2
    (lambda (new o1 o2 lat)
      (cond
       ((null? lat) (quote ()))
       ((or (eq? (car lat) o1)
            (eq? (car lat) o2))
        (cons new (cdr lat)))
       (else
        (cons (car lat)
              (subst2 new o1 o2
                      (cdr lat)))))))
#+end_src

** multirember

This is the =rember= function from above but with an extra level of recursion. This makes it able to replace all occurrences of atom =a= within =lat=.

#+begin_src scheme :tangle src/3.scm
  (define multirember
    (lambda (a lat)
      (cond
       ((null? lat) (quote ()))
       ((eq? (car lat) a)
        (multirember a (cdr lat)))
       (else
        (cons (car lat)
              (multirember a (cdr lat)))))))
#+end_src

** multiinsertR

#+begin_src scheme :tangle src/3.scm
  (define multiinsertR
    (lambda (new old lat)
      (cond
       ((null? lat) (quote ()))
       ((eq? (car lat) old)
        (cons old (cons new (multiinsertR new old (cdr lat)))))
       (else (cons (car lat)
                   (multiinsertR new old (cdr lat)))))))
#+end_src

